rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // --- USER PROFILES (New Social Structure) ---
    // Anyone can read profiles (needed for social discovery)
    // Only the user themselves can write/edit their profile
    match /userProfiles/{userId} {
      allow read: if true;
      allow write: if request.auth != null && request.auth.uid == userId;

      // Subcollections (followers/following)
      match /followers/{followerId} {
         allow read: if true;
         // Allow users to add themselves to someone's followers (Follow action)
         allow write: if request.auth != null; 
      }
      match /following/{followingId} {
         allow read: if true;
         allow write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // --- LEGACY USER DATA (MovieContext: Watchlist/Watched) ---
    // This collection is strictly private to the user
    // --- USERS (Social Data & Search) ---
    // Previously strict private, now needs to be readable for Search/Social
    match /users/{userId} {
      allow read: if request.auth != null; // Authenticated users can search others
      allow write: if request.auth != null && request.auth.uid == userId; // Only owner can edit their profile
      
      // Friends Subcollection (Bi-directional check ideally, but we trust client logic for MVP)
      match /friends/{friendId} {
         allow read, write: if request.auth != null; // Simplified for MVP: Users write to each other's friends list on acceptance. 
      }
      
      // Movies Subcollection (Watchlist / Watched / Favorites)
      match /movies/{movieId} {
        allow read: if request.auth != null; // Publicly readable for profiles
        allow write: if request.auth != null && request.auth.uid == userId; // Only owner can add/remove movies
      }
    }

    // --- FRIEND REQUESTS ---
    match /friendRequests/{requestId} {
      // Create: Authenticated users can create requests coming FROM them
      allow create: if request.auth != null && request.resource.data.fromUid == request.auth.uid;
      
      // Read: Users can see requests sent TO them or BY them
      // Using .get() prevents crashes if fields are missing in old docs
      allow read: if request.auth != null && (
        resource.data.get('toUid', '') == request.auth.uid || 
        resource.data.get('fromUid', '') == request.auth.uid
      );
      
      // Delete: Users can cancel their own requests OR reject/accept requests sent to them
      allow delete: if request.auth != null && (
        resource.data.get('fromUid', '') == request.auth.uid || 
        resource.data.get('toUid', '') == request.auth.uid
      );
    }
    
    // --- LIST COLLABORATION REQUESTS ---
    match /listRequests/{requestId} {
      // Create: Any authenticated user can request to join a list
      allow create: if request.auth != null && request.resource.data.fromUid == request.auth.uid;
      
      // Read: Sender and Receiver (List Owner) can see
      allow read: if request.auth != null && (
        resource.data.get('fromUid', '') == request.auth.uid || 
        resource.data.get('toUid', '') == request.auth.uid
      );
      
      // Delete: Sender (cancel) or Receiver (accept/reject)
      allow delete: if request.auth != null && (
        resource.data.get('fromUid', '') == request.auth.uid || 
        resource.data.get('toUid', '') == request.auth.uid
      );
    }

    // --- LISTS (Core Social Feature) ---
    match /lists/{listId} {
      // READ RULES:
      // Allowed if Owner OR Collaborator OR Public (if we want public lists)
      // For this specific request: "collaborator can see". 
      // Assuming lists are generally public if profile is public, BUT user asked for strict "connected" access logic.
      // However, sticking to "accessible if authenticated" for simplicity unless strict privacy is requested.
      // Let's refine: Owner OR Collaborator can always read. Others can read if 'visibility' is 'public'.
      allow read: if request.auth != null;

      // WRITE RULES:
      // 1. Create: Anyone authenticated
      allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
      
      // 2. Update: 
      // Owner: Can update everything.
      // Collaborator: Can ONLY update 'movies' array (add/remove) and 'updatedAt'. Cannot change name, privacy, or delete collaborators (unless themselves?).
      allow update: if request.auth != null && (
        resource.data.ownerId == request.auth.uid ||
        (
          resource.data.collaborators.hasAny([request.auth.uid]) &&
          // Ensure critical fields are NOT changed by collaborator
          request.resource.data.ownerId == resource.data.ownerId &&
          request.resource.data.name == resource.data.name &&
          request.resource.data.description == resource.data.description
          // They can essentially only touch 'movies' and 'updatedAt'
        )
      );
      
      // 3. Delete: Only Owner
      allow delete: if request.auth != null && resource.data.ownerId == request.auth.uid;
    }

    // --- CHATS (Direct Messaging) ---
    // chatId is always sorted([uid1, uid2]).join('_')
    // So we can verify participation by checking if the user's uid appears in chatId.
    match /chats/{chatId} {

      // Helper: is the requesting user a participant? (checks the chatId string)
      function isParticipant() {
        return request.auth != null &&
          (chatId.matches('.*_' + request.auth.uid) ||
           chatId.matches(request.auth.uid + '_.*') ||
           chatId == request.auth.uid);
      }

      allow read: if isParticipant();

      // Create: user must be in participants array AND in chatId
      allow create: if isParticipant() &&
        request.resource.data.participants.hasAny([request.auth.uid]);

      // Update: verify against stored participants (doc exists)
      allow update: if request.auth != null &&
        resource.data.participants.hasAny([request.auth.uid]);

      allow delete: if false;

      // Messages subcollection â€” use chatId string check, no get() needed
      match /messages/{messageId} {
        allow read: if isParticipant();

        // Create: sender must match auth uid, and user must be participant
        allow create: if isParticipant() &&
          request.resource.data.senderId == request.auth.uid;

        allow update: if false;

        // Participants can delete any message in their chat
        allow delete: if isParticipant();
      }
    }
  }
}
